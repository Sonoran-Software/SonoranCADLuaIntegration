"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SequentialHandler_asyncQueue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequentialHandler = void 0;
// import { setTimeout as sleep } from 'node:timers/promises';
const async_queue_1 = require("@sapphire/async-queue");
const node_fetch_1 = __importDefault(require("node-fetch"));
const node_abort_controller_1 = require("node-abort-controller");
// import { DiscordAPIError, DiscordErrorData, OAuthErrorData } from '../errors/DiscordAPIError';
const errors_1 = require("../errors");
const HTTPError_1 = require("../errors/HTTPError");
class SequentialHandler {
    /**
     * @param manager The request manager
     * @param hash The hash that this RequestHandler handles
     * @param majorParameter The major parameter for this handler
     */
    constructor(manager, data) {
        this.manager = manager;
        this.data = data;
        /**
         * The total number of requests that can be made before we are rate limited
         */
        // private limit = Infinity;
        /**
         * The interface used to sequence async requests sequentially
         */
        // eslint-disable-next-line @typescript-eslint/explicit-member-accessibility
        _SequentialHandler_asyncQueue.set(this, new async_queue_1.AsyncQueue());
        this.id = `${this.data.typePath}:${String(this.data.product)}`;
    }
    /**
     * If the bucket is currently inactive (no pending requests)
     */
    get inactive() {
        return (__classPrivateFieldGet(this, _SequentialHandler_asyncQueue, "f").remaining === 0);
    }
    getMang() {
        return this.manager;
    }
    /**
     * Emits a debug message
     * @param message The message to debug
     */
    // private debug(message: string) {
    // 	this.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);
    // }
    /*
     * Determines whether the request should be queued or whether a RateLimitError should be thrown
     */
    // private async onRateLimit(rateLimitData: RateLimitData) {
    // 	const { options } = this.manager;
    // 	if (options.rejectOnRateLimit) {
    // 		throw new RateLimitError(rateLimitData);
    // 	}
    // }
    /**
     * Queues a request to be sent
     * @param routeId The generalized api route with literal ids for major parameters
     * @param url The url to do the request on
     * @param options All the information needed to make a request
     * @param requestData Extra data from the user's request needed for errors and additional processing
     */
    async queueRequest(url, options, data) {
        let queue = __classPrivateFieldGet(this, _SequentialHandler_asyncQueue, "f");
        // Wait for any previous requests to be completed before this one is run
        await queue.wait();
        try {
            // Make the request, and return the results
            return await this.runRequest(url, options, data);
        }
        finally {
            // Allow the next request to fire
            queue.shift();
        }
    }
    /**
     * The method that actually makes the request to the api, and updates info about the bucket accordingly
     * @param routeId The generalized api route with literal ids for major parameters
     * @param url The fully resolved url to make the request to
     * @param options The node-fetch options needed to make the request
     * @param requestData Extra data from the user's request needed for errors and additional processing
     * @param retries The number of retries this request has already attempted (recursion)
     */
    async runRequest(url, options, data) {
        const controller = new node_abort_controller_1.AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000).unref();
        let res;
        void this.manager.debug(`[${url} Request] - ${JSON.stringify({ url, options, data })}`);
        try {
            // node-fetch typings are a bit weird, so we have to cast to any to get the correct signature
            // Type 'AbortSignal' is not assignable to type 'import('discord.js-modules/node_modules/@types/node-fetch/externals').AbortSignal'
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            res = await (0, node_fetch_1.default)(url, { ...options, signal: controller.signal });
        }
        catch (error) {
            throw error;
        }
        finally {
            clearTimeout(timeout);
        }
        const parsedRes = await SequentialHandler.parseResponse(res);
        void this.manager.debug(`[${url} Response] - ${JSON.stringify({ body: parsedRes, res, status: res.status, headers: res.headers })}`);
        if (res.ok) {
            return parsedRes;
        }
        else if (res.status === 400 || res.status === 401 || res.status === 404) {
            throw new errors_1.APIError(parsedRes, data.type, data.fullUrl, res.status, data);
        }
        else if (res.status === 429) {
            const timeout = setTimeout(() => {
                this.manager.removeRateLimit(data.requestTypeId);
            }, 60 * 1000);
            const ratelimitData = {
                product: data.product,
                type: data.type,
                timeTill: timeout
            };
            this.manager.onRateLimit(data.requestTypeId, ratelimitData);
        }
        else if (res.status >= 500 && res.status < 600) {
            throw new HTTPError_1.HTTPError(res.statusText, res.constructor.name, res.status, data.method, url);
        }
        return null;
    }
    static parseResponse(res) {
        var _a;
        if ((_a = res.headers.get('Content-Type')) === null || _a === void 0 ? void 0 : _a.startsWith('application/json')) {
            return res.json();
        }
        return res.text();
    }
}
exports.SequentialHandler = SequentialHandler;
_SequentialHandler_asyncQueue = new WeakMap();
