"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestManager = void 0;
const collection_1 = require("@discordjs/collection");
// import { DiscordSnowflake } from '@sapphire/snowflake';
const events_1 = require("events");
const constants_1 = require("./utils/constants");
const constants_2 = require("../../../../constants");
const SequentialHandler_1 = require("./handlers/SequentialHandler");
const utils_1 = require("../../../../utils/utils");
class RequestManager extends events_1.EventEmitter {
    constructor(_instance, _product, options) {
        super();
        this.ratelimitedTypes = new collection_1.Collection();
        this.handlers = new collection_1.Collection();
        this.product = _product;
        this.instance = _instance;
        switch (_product) {
            case constants_2.productEnums.CAD: {
                this.options = { ...constants_1.DefaultCADRestOptions, ...options };
                break;
            }
            case constants_2.productEnums.CMS: {
                this.options = { ...constants_1.DefaultCMSRestOptions, ...options };
                break;
            }
            default: {
                throw new Error('No Product provided for RequestManager initialization');
            }
        }
    }
    async queueRequest(request) {
        var _a;
        let requestData = request;
        const resolvedData = RequestManager.resolveRequestData(this.instance, request.type, request.product, requestData);
        const handler = (_a = this.handlers.get(`${resolvedData.typePath}:${String(request.product)}`)) !== null && _a !== void 0 ? _a : this.createHandler(resolvedData);
        return handler.queueRequest(resolvedData.fullUrl, resolvedData.fetchOptions, resolvedData);
    }
    onRateLimit(id, rateLimitData) {
        this.ratelimitedTypes.set(id, rateLimitData);
    }
    removeRateLimit(id) {
        this.ratelimitedTypes.delete(id);
    }
    createHandler(data) {
        const queue = new SequentialHandler_1.SequentialHandler(this, data);
        this.handlers.set(queue.id, queue);
        return queue;
    }
    static resolveRequestData(instance, type, product, data) {
        let apiURL = false;
        let apiData = {
            requestTypeId: `${type}:${String(product)}`,
            typePath: '',
            fullUrl: '',
            method: '',
            fetchOptions: {},
            data,
            product,
            type
        };
        switch (product) {
            case constants_2.productEnums.CAD:
                apiURL = instance.cadApiUrl;
                break;
            case constants_2.productEnums.CMS:
                apiURL = instance.cmsApiUrl;
                break;
        }
        const findType = constants_1.AllAPITypes.find((_type) => _type.type === type);
        if (findType) {
            apiData.fullUrl = `${apiURL}/${findType.path}`;
            apiData.method = findType.method;
            apiData.fetchOptions.method = findType.method;
            apiData.typePath = findType.path;
            const clonedData = (0, utils_1.cloneObject)(data.data);
            switch (findType.type) {
                case 'SET_SERVERS': {
                    apiData.data.data = clonedData;
                    break;
                }
                case 'SET_PENAL_CODES': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'SET_API_ID': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'NEW_RECORD': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'EDIT_RECORD': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'LOOKUP_INT': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'LOOKUP': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'SET_ACCOUNT_PERMISSIONS': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'BAN_USER': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'AUTH_STREETSIGNS': {
                    apiData.data.data = clonedData;
                    break;
                }
                case 'SET_POSTALS': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'NEW_CHARACTER': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'EDIT_CHARACTER': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'MODIFY_IDENTIFIER': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'ADD_BLIP': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'MODIFY_BLIP': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'GET_CALLS': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'GET_ACTIVE_UNITS': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'NEW_DISPATCH': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                case 'UNIT_LOCATION': {
                    apiData.data.data = [clonedData[0]];
                    break;
                }
                default: {
                    if (data.data) {
                        if (Array.isArray(data.data)) {
                            if (data.data.length > 0) {
                                apiData.data.data = [clonedData];
                            }
                            else {
                                apiData.data.data = [];
                            }
                        }
                        else {
                            apiData.data.data = [clonedData];
                        }
                    }
                    else {
                        apiData.data.data = [];
                    }
                    break;
                }
            }
        }
        apiData.fetchOptions.body = JSON.stringify(apiData.data);
        apiData.fetchOptions.headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            ...instance.apiHeaders
        };
        return apiData;
    }
    debug(log) {
        return this.instance._debugLog(log);
    }
}
exports.RequestManager = RequestManager;
